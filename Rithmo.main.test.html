<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Rithmomachia</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap');

		body {
			margin: 0;
			padding: 20px;
			background-color: #533c3c;
		}

		.overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.0);
			z-index: 9999;
			pointer-events: none;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		video {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}

		.container {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 20px;
			height: 91vh;
			max-width: 1200px;
			margin: 0 auto;
			position: relative;
		}

		.title {
			font-family: 'Playfair Display', serif;
			font-size: 48px;
			font-weight: 600;
			width: 350px;
			padding: 15px;
			margin: 0px;
			text-align: center;
			background-color: #620404;
			border-radius: 100px;
			color: #000000;
		}

		.game-controls {
			position: absolute;
			top: 20px;
			right: 2.5%;
			/* Indicates the percentage/pixles from the right side of the area it resides in*/
			display: flex;
			flex-direction: row;
			gap: 10px;
			z-index: 100;
			max-width: calc(31%);
			/* Width limited to avoid reaching the title */
			flex-wrap: wrap;
			justify-content: flex-start;
			align-items: center;
		}

		.game-container {
			display: flex;
			gap: 20px;
			width: 100%;
			justify-content: center;
		}

		.custom-file-label {
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			display: inline-block;
			border-radius: 10px;
		}

		#black-pyramid {
			background-color: black;
			color: white;
			border-radius: 5px;
			text-justify: inter-word;
			text-align: center;
			height: 300px;
			min-width: 85px;
			width: 85px;
			/* Added order attribute for team change functionality and moving the pyramid display Darin*/
			order: -1;
		}

		#white-pyramid {
			background-color: white;
			color: black;
			border-radius: 5px;
			text-align: center;
			height: 300px;
			min-width: 85px;
			width: 85px;
			/* Order here too Darin*/
			order: 1;
		}

		.game-controls button {
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			border-radius: 10px;
		}

		#game-board {
			position: relative;
			width: fit-content;
			max-width: 1000px;
			max-height: 500;
			border: 2px solid #333;
			border-radius: 8px;
			overflow: hidden;
		}

		#gameCanvas {
			position: absolute;
			top: 0;
			left: 0;
		}

		#StartScreen {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			position: relative;
			width: 1000px;
			height: 800px;
			border-radius: 20px;
			padding: 20px;
			overflow: hidden;
		}

		#SetupScreen {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: flex-start;
			position: relative;
			width: 1000px;
			border-radius: 20px;
			padding: 20px;
			padding-top: 60px;
			/* Added extra padding at top for title */
			background-color: rgba(83, 60, 60, 0.8);
			box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
		}

		#SetupScreen h2 {
			color: black;
			text-align: center;
			text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
			position: relative;
			z-index: 2;
			/* Keeps it above the background */
			margin-top: 20px;
			/* Adds space below the title */
			/* If needed, you could also use padding-top instead */
		}

		#victoryForm {
			margin-top: 30px;
			/* Added space between title and form */
			width: 90%;
			max-width: 800px;
		}

		.victory-list {
			list-style-type: none;
			padding: 0;
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 15px;
			width: 100%;
		}

		.victory-item {
			margin-bottom: 10px;
			padding: 15px;
			border: 1px solid #666666;
			border-radius: 5px;
			background-color: #888888;
			transition: background-color 0.3s;
		}

		.victory-item:hover {
			background-color: #999999;
		}

		.victory-item label {
			display: flex;
			align-items: center;
			cursor: pointer;
			font-size: 18px;
			font-weight: normal;
		}

		.victory-item-tier {
			list-style-type: none;
			margin-bottom: 5px;
			padding: 10px;
			border: 1px solid #666666;
			border-radius: 5px;
			background-color: #888888;
			transition: background-color 0.3s;
			width: 90%;
			max-width: 600px;
		}

		.victory-item-tier:hover {
			background-color: #999999;
		}

		.victory-item-tier label {
			display: flex;
			align-items: center;
			cursor: pointer;
			font-size: 18px;
			font-weight: normal;
		}

		.dropdown-container {
			margin-top: 10px;
			margin-left: 25px;
			display: none;
			padding: 10px;
			background-color: #f5f5f5;
			border-radius: 4px;
		}

		.dropdown-container.active {
			display: block;
		}

		.save-confirmation {
			color: #4CAF50;
			font-weight: bold;
			opacity: 0;
			transition: opacity 0.3s ease;
			margin: 10px 0;
			text-align: center;
		}

		.save-confirmation.show {
			opacity: 1;
		}

		/* Added to flip background without flipping the entire start screen Darin */
		#backgroundWrapper {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			/* Unneeded. Background wrapper switches regardless of what is listed here. Should only be a static background image before the user switches it. */
			background-image:
			/*`url(${THEMES[currentTheme].board})`*/
			url('Images/HUNT-Pieces/HUNT-NewBoard-01.png');
			background-size: cover;
			background-position: center;
			transition: transform 0.5s ease;
			transform-origin: center center;
		}

		/* Added a grouping of the start screen buttons to format instead of listing them individually. Also gave start screen buttons a hover effect Darin */
		#StartScreen button {
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			border-radius: 10px;
			font-size: 20px;
			margin: 10px 0;
			transform: rotate(0deg) !important;
			transition: background-color 0.3s ease;
			z-index: 1;
			width: 370px;
			height: 40px;
			text-align: center;
		}

		#SetupScreen button {
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			border-radius: 10px;
			font-size: 20px;
			margin: 10px 0;
			transform: rotate(0deg) !important;
			transition: background-color 0.3s ease;
			z-index: 999;
			width: 370px;
			height: 40px;
			text-align: center;
		}

		#StartScreen button:hover {
			background-color: #888888;
		}

		#StartScreen button:active {
			background-color: #666666;
		}


		.hidden {
			display: none !important;
		}

		#themeSelect {
			position: relative;
			z-index: 10;
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			border-radius: 10px;
			font-size: 20px;
			margin: 10px 0;
			transform: rotate(0deg) !important;
			transition: background-color 0.3s ease;
			z-index: 1;
			width: 370px;
			height: 40px;
			text-align: center;
		}

		#GameInfo {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background-color: rgba(0, 0, 0, 0.6);
			display: flex;
			align-items: flex-start;
			justify-content: center;
			overflow-y: auto;
			padding: 40px 20px;
			z-index: 9999;
		}

		.infoSlide {
			background-color: #fff;
			color: #333;
			font-family: 'Georgia', serif;
			padding: 40px;
			max-width: 800px;
			width: 100%;
			border-radius: 16px;
			box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
			line-height: 1.6;
			font-size: 16px;
			position: relative;
		}

		.infoSlide h1 {
			font-size: 32px;
			color: #222;
			margin-bottom: 20px;
		}

		.infoSlide p {
			margin-bottom: 20px;
		}

		#backButton {
			position: absolute;
			top: 20px;
			right: 20px;
			background-color: #4A90E2;
			color: #fff;
			border: none;
			padding: 10px 16px;
			border-radius: 8px;
			font-size: 14px;
			cursor: pointer;
			transition: background-color 0.3s ease;
		}

		#backButton:hover {
			background-color: #357ABD;
		}
	</style>
</head>

<body>
	<div class="container">
		<div class="overlay" id="videoContainer"></div>
		<h1 class="title">Rithmomachia</h1>
		<div id="StartScreen">
			<!-- Background wrapper for image of background board on start screen Darin -->
			<div id="backgroundWrapper"></div>
			<button id="startButton">Start Game</button>
			<button id="muteButton">Mute</button>
			<button id="teamChangeButton">Change Team (Current team: Black)</button>
			<!-- <button class="volumeButton">Volume</button> -->
			<button class="infoButton">Game Info</button>
			<select id="themeSelect" title="Theme">
				<option value="Daniel_Hunt">Daniel Theme</option>
				<option value="Lulu_Burkowski">Lulu Theme</option>
				<option value="Jessie_Reed">Jessie Theme</option>
			</select>
		</div>

		<div id="SetupScreen" class="hidden">
			<!-- //These Dont do anything for now but are here for in the future -->
			<h2>Victory Conditions</h2>
			<form id="victoryForm">
				<ul class="victory-list">
					<li class="victory-item">
						<label>
							<input type="radio" name="victoryCommon" value="BODIES" checked> Victory of Bodies
						</label>
						<div class="dropdown-container" id="BODIES-dropdown">
							<label for="bodiesGoal">Number of Pieces required:
								<input type="number" id="bodiesGoal(BODIES)" name="bodiesGoal" min="1" value="3">
							</label>
						</div>
					</li>
					<li class="victory-item">
						<label>
							<input type="radio" name="victoryCommon" value="GOODS"> Victory of Goods
						</label>
						<div class="dropdown-container" id="GOODS-dropdown">
							<label for="valueGoal">Value of Pieces required (Total of Top Numbers):
								<input type="number" class="valueGoal(GOODS)" name="valueGoal" min="1" value="100">
							</label>
						</div>
					</li>
					<li class="victory-item">
						<label>
							<input type="radio" name="victoryCommon" value="QUARREL"> Victory of Quarrel
						</label>
						<div class="dropdown-container" id="QUARREL-dropdown">
							<label for="valueGoal">Value of Pieces required (Total of Top Numbers):
								<input type="number" id="valueGoal(QUARREL)" name="valueGoal" min="1" value="100">
							</label>
							<label for="digitsGoal">Total required digits captured between pieces:
								<input type="number" id="digitsGoal(QUARREL)" name="digitsGoal" min="1" value="10">
							</label>
						</div>
					</li>
					<li class="victory-item">
						<label>
							<input type="radio" name="victoryCommon" value="HONOR"> Victory of Honor
						</label>
						<div class="dropdown-container" id="HONOR-dropdown">
							<label for="bodiesGoal">Number of Pieces required:
								<input type="number" id="bodiesGoal(Honor)" name="bodiesGoal" min="1" value="3">
							</label>
							<label for="valueGoal">Value of Pieces required (Total of Top Numbers):
								<input type="number" id="valueGoal(Honor)" name="valueGoal" min="1" value="100">
							</label>
						</div>
					</li>
					<li class="victory-item">
						<label>
							<input type="radio" name="victoryCommon" value="HONOR_AND_QUARREL"> Victory of Honor and
							Quarrel
						</label>
						<div class="dropdown-container" id="HONOR_AND_QUARREL-dropdown">
							<label for="bodiesGoal">Number of Pieces required:
								<input type="number" id="bodiesGoal(Honor_and_QUARREL)" name="bodiesGoal" min="1"
									value="3">
							</label>
							<label for="valueGoal">Value of Pieces required (Total of Top Numbers):
								<input type="number" id="valueGoal(Honor_and_QUARREL)" name="valueGoal" min="1"
									value="100">
							</label>
							<label for="digitsGoal">Total required digits captured between pieces:
								<input type="number" id="digitsGoal(Honor_and_QUARREL)" name="digitsGoal" min="1"
									value="10">
							</label>
						</div>
					</li>
				</ul>
				<!-- Nammari said the java does not have ways to swap glorious victories so commenting this out for now -Darin -->
				<!-- <ul>
					<li class="victory-item-tier" data-tier="1">
						<label>
							<div class="checkbox-container">
								<input type="checkbox" name="victoriaMagna" value="1">
							</div>
							<div>
								<div class="tier-name">Victoria Magna (Good Victory)</div>
							</div>
						</label>
					</li>
					<li class="victory-item-tier" data-tier="2">
						<label>
							<div class="checkbox-container">
								<input type="checkbox" name="victoriaMayor" value="2">
							</div>
							<div>
								<div class="tier-name">Victoria Mayor (Great Victory)</div>
							</div>
						</label>
					</li>
					<li class="victory-item-tier" data-tier="3">
						<label>
							<div class="checkbox-container">
								<input type="checkbox" name="victoriaExcelentisima" value="3">
							</div>
							<div>
								<div class="tier-name">Victoria Excelentisima (Excellent Victory)</div>
							</div>
						</label>
					</li>
				</ul> -->
			</form>
			<!-- Probably wont need this save button either. -Darin -->
			<!-- <button id="saveVictoriesBtn">Save Changes</button> -->
			<p id="saveConfirmation" class="save-confirmation">Victory conditions saved!</p>
			<button id="ContinueToGame">Continue</button>
		</div>

		<div id="GameScreen" class="hidden">
			<div class="game-controls">
				<label id="fileLabel" for="moveFileInput" class="custom-file-label">Open File</label>
				<input type="file" id="moveFileInput" accept=".txt" style="display:none;" />
				<button id="endLoopButton" onclick="handleReset()">Reset</button>
				<button id="pause" onclick="PauseButton()">Pause</button>
				<button id="volumeButton">Volume</button>
				<button class="infoButton" id="InfoButton">Game Info</button>
			</div>
			<div class="game-container">
				<div id="black-pyramid">
					<h3>Black<br />Pyramid</h3>
				</div>
				<div id="game-board">
					<canvas id="gameCanvas"></canvas>
				</div>
				<div id="white-pyramid">
					<h3>White<br />Pyramid</h3>
				</div>
			</div>
		</div>
	</div>

	<div id="GameInfo" class="hidden">
		<div class="infoSlide">

			<h1>Welcome to Rithmomachia!</h1>

			<p>In Rithmomachia, players choose a victory condition at the start—<strong>BODIES</strong>,
				<strong>GOODS</strong>,
				<strong>QUARREL</strong>, <strong>Honor</strong>, or <strong>Honor + QUARREL</strong>. Victory is
				achieved by capturing opponent pieces using one of four
				methods: <strong>Siege</strong>, <strong>Encounter</strong>, <strong>Eruption</strong>, or
				<strong>Deceit</strong>.
				Each capture requires specific mathematical calculations based on the pieces' values and movement
				patterns.
				Finally, there are also special victories named glorious victories—<em>Victoria magna</em>, <em>Victoria
					major</em>,
				and <em>Victoria excellentissima</em>. Each of these concepts will be explained in the upcoming slides
				starting with piece values and
				movement rules.
			</p>

			<h2>What is Rithmomachia?</h2>

			<p><strong>Rithmomachia</strong>, also known as <em>the Battle of Numbers</em>, is a medieval mathematical
				board game
				developed in the 11th century. Deeply rooted in classical and scholastic learning, it was designed as
				both an
				educational tool and an intellectual game. Played primarily by scholars, the game blends strategy with
				arithmetic,
				requiring players to use numbers, ratios, and progressions to outmaneuver their opponents.</p>

			<h3>Game Setup</h3>
			<p>The board usually consists of 8 rows and 16 columns. Each player begins with 24 pieces: circles,
				triangles, squares,
				and pyramids. These shapes are not merely decorative—each bears a number based on arithmetic, geometric,
				or harmonic
				progression. <strong>Pyramids</strong> are especially significant as they combine the values of the
				other shapes and represent the
				height of numerical harmony.</p>

			<h3>Piece Movement</h3>
			<p>Movement is determined both by piece shape and value:</p>
			<ul>
				<li><strong>Circles</strong> move straight (horizontally or vertically).</li>
				<li><strong>Triangles</strong> move diagonally.</li>
				<li><strong>Squares</strong> leap according to specific numeric patterns.</li>
				<li><strong>Pyramids</strong> may combine multiple movement types or have restricted movement depending
					on strategy.</li>
			</ul>

			<h3>Capture Methods</h3>
			<p>Capturing in Rithmomachia is governed by mathematical logic:</p>
			<ul>
			    <li><strong>Siege</strong>: A piece is captured when it is surrounded on four sides, either in a plus (+) or X formation.</li>
			    <li><strong>Encounter</strong>: If an attacking piece can validly move onto a spot thats occupied by a piece of identical value, the enemy piece is captured and removed from the board.</li>
			    <li><strong>Eruption</strong>: The value of the atatcking piece is multiplied or divided by the number of spaces between its quarry must be equal to the enemy's value. (The distance between the spaces that each piece occupies)</li>
			    <li><strong>Deceit</strong>: Captures use unexpected arithmetic tricks, such as sums or differences that appear harmless until triggered.</li>
			</ul>
			
			<h3>Victory Types</h3>
			<p>Victory can be achieved in several ways:</p>

			<ul>
				<li><strong>Standard Victory Types</strong> (These have to be chosen before the game starts):
					<ul>
						<li><strong>BODIES Victory</strong>: Scoring is based on the number of pieces captured. Players
							earn or lose points depending on how many pieces they capture without exceeding the victory
							goal.</li>
						<li><strong>GOODS Victory</strong>: Points are awarded or deducted based on the total numerical
							value of the captured pieces, as long as the goal isn't surpassed.</li>
						<li><strong>QUARREL Victory</strong>: Combines both the value of the pieces and the number of
							digits in those values to calculate score changes, without going over the target.</li>
						<li><strong>Honor Victory</strong>: Mixes both the number of pieces and their values to
							determine progress toward victory, ensuring totals stay below the limit.</li>
						<li><strong>Honor and QUARREL Victory</strong>: A comprehensive goal that factors in piece
							count, numerical value, and digit count of captured pieces, rewarding balanced and strategic
							captures that remain under the goal threshold.</li>
					</ul>
				</li>
				<li><strong>Glorious Victories</strong> (These can happen in any game at any point):
					<ul>
						<li><strong>Victoria Magna</strong>: Achieved by forming a complete and visible Arithmetic,
							Geometric or Harmonic sequence using one's pieces on the board on the opponents side.</li>
						<li><strong>Victoria Major</strong>: Achieved by forming a complete and visible sequence with
							two sequences (Arithmetic, Geometric or Harmonic) in it using one's pieces on the board on
							the opponents side.</li>
						<li><strong>Victoria Excellentissima</strong>: Achieved by forming a complete and visible
							sequence with all three sequences in it (Arithmetic, Geometric or Harmonic) using one's
							pieces on the board on the opponents side.</li>
					</ul>
				</li>
			</ul>


			<h2>Core Game Rules</h2>
			<ul>
				<li>The board is 8×16 with each player starting on opposite ends.</li>
				<li>Each player has 24 pieces: 8 circles, 8 triangles, 8 squares, and pyramids (combinations).</li>
				<li>Pieces bear numeric values based on progressions (arithmetic, geometric, harmonic).</li>
				<li>Pieces capture by matching, progressing, surrounding, or summing based on numerical relationships.
				</li>
				<li>Victory types must be declared at game start.</li>
				<li>Players may win early by forming a visible mathematical progression of pieces.</li>
				<li>Captured pieces are removed and contribute to calculating GOODS or Honor totals.</li>
				<li>Game ends when a victory condition is achieved or one player concedes.</li>
			</ul>

			<!-- Separtate this into catagories of contribution (programmers/art/overseers/etc) and get the art students in here as well as Tronicek.-->
			<!--Also ask tronicek who to credit here as im not sure who else contributed to this project.-->
				<h2>Contributors</h2>
				
				<h3>Programmers</h3>
				<ul>
				    <li>Jacob Spoor</li>
				    <li>Grady Suchocki</li>
				    <li>Darin Mullen</li>
				    <li>Nammari Drayton</li>
				    <li>Ethan Biles</li>
				    <li>Dylan Elman</li>
				    <li>Jacob Pincus</li>
				    <li>Dylan Bellinger</li>
				</ul>
				
				<h3>Art Students</h3>
				<ul>
				    <li>Daniel Hunt</li>
	                            <li>Jessie Reed</li>
				    <li>Lulu Burkowski</li>
				</ul>
				
				<h3>Faculty & Researchers</h3>
				<ul>
				    <li>Zdenek Tronicek</li>
				    <li>Toke Knudsen</li>
			            <li>Emily Petramale</li>
				</ul>
			
			<button id="backButton">Back to Game</button>
		</div>

	</div>

	<!--Preload Intro video Darin-->
	<video id="introVideo" preload="auto" style="display: none;">
		<source src="Images/Rith/HUNTRithCutscene.mp4" type="video/mp4">
	</video>
	<input id="gameId" type="text" readonly size="40" class="hidden" />

	<script>
		let activeVictoryConditions = {};
		let isMuted = false;
		let currentFileReader = null;
		let currentTheme = "Daniel_Hunt";
		//Team variable used to determine which team the player is Darin
		let team = "Black";
		let CANVAS_WIDTH;
		let CANVAS_HEIGHT;
		let stopExecution = false;
		//Not in original main file but breaks code if removed.
		let length;
		let height;

		let hidden;

		const THEMES = {
			Lulu_Burkowski: {
				board: 'Images/Rithmomachia/Board and pieces/Board-Rotate.png',
				pieces: {
					base: 'Images/Rithmomachia/Board and pieces',
					blackPyramid: 'Images/Rithmomachia/Board and pieces/Black_Pyramid.png',
					whitePyramid: 'Images/Rithmomachia/Board and pieces/White_Pyramid.png',
					pieceFormat: (value, isWhite, type) => `Images/rithmomachia/Board and pieces/${value}_${isWhite ? 'White' : 'Black'}_${{
						's': 'Square',
						't': 'Triangle',
						'c': 'Circle'
					}[type]
						}.png`
				},
				videos: {
					//Changed isWhite to act like the team variable. -Darin
					intro: `Images/Rithmomachia/captures and intro with sound/Intro.mp4`,
					siege: (/* type, */ isWhite) => `Images/rithmomachia/captures and intro with sound/Siege ${isWhite == "Black" ? 'black' : 'white'}.mp4`,
					encounter: (/* type, */ isWhite) => `Images/rithmomachia/captures and intro with sound/Encounter ${isWhite == "Black" ? 'black' : 'white'}.mp4`,
					eruption: (/* type, */ isWhite) => `Images/rithmomachia/captures and intro with sound/Eruption ${isWhite == "Black" ? 'black' : 'white'}.mp4`,
					deceit: (/* type, */ isWhite) => `Images/rithmomachia/captures and intro with sound/Deceit ${isWhite == "Black" ? 'black' : 'white'}.mp4`
				},
				//%scale, x is width of pieces and y is height
				pieceScale: {
					x: 0.75,
					y: 0.75
				},
				//This is the offset each piece is at
				pieceOffset: {
					left: 65 / 2,
					top: 31.25 / 2
				},
				//This is the size of the grid cells with length being x related and height being y related
				cellSize: {
					length: 58.4375,
					height: 58.59375
				},
				//Offset of grid for enable snapping and move piece
				gridOffset: {
					centerX: 125 / 4,
					centerY: 17
				},
				//Canvas dimensions for board
				canvasDim: {
					width: 1000,
					height: 500
				}

			},
			Jessie_Reed: {
				board: 'Images/Rithmomachia Art/Board.png',
				pieces: {
					base: 'Images/Rithmomachia Art/',
					whitePyramid: 'Images/Rithmomachia Art/White_Pyramid.png',
					blackPyramid: 'Images/Rithmomachia Art/Black_Pyramid.png',
					pieceFormat: (value, isWhite, type) => `Images/rithmomachia Art/${value}_${isWhite ? 'White' : 'Black'}_${{
						's': 'Square',
						't': 'Triangle',
						'c': 'Circle',
					}[type]
						}.png`
				},
				videos: {
					intro: 'Images/Rithmomachia Art/Intro final animation with sound.MP4',
					siege: (isWhite) => 'Images/Rithmomachia Art/Siege final draft with sound.MP4',
					encounter: (isWhite) => 'Images/Rithmomachia Art/Encounter final draft with sound.MP4',
					eruption: (isWhite) => 'Images/Rithmomachia Art/Eruption final draft with sound.MP4',
					deceit: (isWhite) => 'Images/Rithmomachia Art/Deceit final draft with sound.MP4'
				},
				pieceScale: {
					x: .94,
					y: .82
				},
				pieceOffset: {
					left: 71,
					top: 71
				},
				cellSize: {
					length: 680 / 16,
					height: 392 / 8
				},
				gridOffset: {
					centerX: 71,
					centerY: 71
				},
				canvasDim: {
					width: 925,
					height: 480
				}

			},
			Daniel_Hunt: {
				board: 'Images/HUNT-Pieces/HUNT-NewBoard-01.png',
				pieces: {
					base: 'Images/HUNT-Pieces/',
					whitePyramid: 'Images/HUNT-Pieces/StackWhite.png',
					blackPyramid: 'Images/HUNT-Pieces/StackBrown.png',
					pieceFormat: (value, isWhite, type) => `Images/HUNT-Pieces/${{
						's': 'Sq',
						't': 'Tri',
						'c': 'Circ'
					}[type]
						}${value}.png`
				},
				videos: {
					intro: 'Images/Rith/HUNTRithCutscene.mp4',
					siege: (isWhite) => 'Images/Rith/Siege Video.mp4',
					encounter: (isWhite) => 'Images/Rith/Encounter Video.mp4',
					eruption: (isWhite) => 'Images/Rith/Eruption Video.mp4',
					deceit: (isWhite) => 'Images/Rith/Deceit Video.mp4'
				},
				pieceScale: {
					x: 0.76,
					y: 0.76
				},
				pieceOffset: {
					left: 92.75,
					top: 75
				},
				cellSize: {
					length: 41,
					height: 46
				},
				gridOffset: {
					centerX: 95,
					centerY: 77
				},
				canvasDim: {
					width: 925,
					height: 480
				}

			}
		};

		// Theme switching functionality
		document.getElementById('themeSelect').addEventListener('change', (e) => {
			currentTheme = e.target.value;
			console.log(currentTheme);

			//Loads intro depending on theme
			let video = document.getElementById('introVideo');
			let source = video.querySelector('source');
			source.src = THEMES[currentTheme].videos.intro;
			video.load();

			//Changes body background if the theme is jessie's as test 2 has a special image for it. 
			if (currentTheme == "Jessie_Reed") {
				document.body.style.backgroundImage = "url('Images/Rithmomachia Art/Background.jpg')";
			}
			else {
				document.body.style.backgroundImage = "none";
			}

			// Only reset the game if it's already started
			if (!document.getElementById('StartScreen').classList.contains('hidden')) {
				updateBackgroundWrapper();
			} else {
				resetGame();
			}
		});

		//Updates start screen background board 
		function updateBackgroundWrapper() {
			const backgroundWrapper = document.getElementById('backgroundWrapper');
			backgroundWrapper.style.backgroundImage = `url('${THEMES[currentTheme].board}')`;
		}

		// Initialize canvas with proper dimensions
		const canvas = new fabric.Canvas('gameCanvas', {
			// width: CANVAS_WIDTH,
			// height: CANVAS_HEIGHT,
			selection: false,
			renderOnAddRemove: true
		});
		//Helper function to set canvas width and height with theme
		function setCanvasWidthandHeight() {
			CANVAS_WIDTH = THEMES[currentTheme].canvasDim.width;
			CANVAS_HEIGHT = THEMES[currentTheme].canvasDim.height;
			canvas.setWidth(CANVAS_WIDTH);
			canvas.setHeight(CANVAS_HEIGHT);
		}

		//Check that intro video is loaded in console -Darin
		const introVideo = document.getElementById("introVideo");
		introVideo.oncanplaythrough = () => {
			console.log("Intro video is preloaded and ready.");
		};

		//Helper function for the cell length and height to set dynamically with theme
		function setLengthandHeight() {
			length = THEMES[currentTheme].cellSize.length;
			height = THEMES[currentTheme].cellSize.height;
		}

		let boardState = Array(8).fill().map(() => Array(16).fill(null));
		let isLooping = true;
		let cont = true;

		//When start button is clicked it hides itself and calls start game -Darin
		document.getElementById('startButton').addEventListener('click', function () {
			document.getElementById('StartScreen').classList.add('hidden');
			document.getElementById('SetupScreen').classList.remove('hidden');
			//StartGame();
		});

		document.getElementById('ContinueToGame').addEventListener('click', function () {
			document.getElementById('SetupScreen').classList.add('hidden');
			StartGame();
		});


		//Function for the team change button. Once pressed behind the scenes the board and pieces are swapped and visually the button changes the current team and the background of start screen flips. Darin
		document.getElementById('teamChangeButton').addEventListener('click', function () {
			const backgroundWrapper = document.getElementById('backgroundWrapper');

			let Black_Pyramid = document.getElementById("black-pyramid");
			let White_Pyramid = document.getElementById("white-pyramid");

			let BlackOrder = window.getComputedStyle(Black_Pyramid).order;
			let WhiteOrder = window.getComputedStyle(White_Pyramid).order;

			Black_Pyramid.style.order = WhiteOrder;
			White_Pyramid.style.order = BlackOrder;

			team = team === "Black" ? "White" : "Black";

			//Different animations for each board when the team is switched 
			if (currentTheme == "Daniel_Hunt") {
				backgroundWrapper.style.transform = `scaleX(${team === "White" ? -1 : 1})`;
			}
			else if (currentTheme == "Jessie_Reed") {
				backgroundWrapper.style.transition = "transform 1s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
				backgroundWrapper.style.transform = `rotate(${team === "White" ? 300 : -120}deg)`;

				setTimeout(() => {
					backgroundWrapper.style.transform = `scaleX(${team === "White" ? -1 : 1})`;
				}, 500);
			}
			else if (currentTheme == "Lulu_Burkowski") {
				backgroundWrapper.style.transition = "transform 1s ease-in-out, scale 0.6s ease-in-out";
				backgroundWrapper.style.transform = "scale(0.7) rotate(360deg)"; // Added rotation

				setTimeout(() => {
					backgroundWrapper.style.transform = "scale(1.1) rotate(0deg)";
				}, 300);

				setTimeout(() => {
					backgroundWrapper.style.transform = `scaleX(${team === "White" ? -1 : 1})`;
				}, 600);
			}



			this.textContent = `Change Team (Current team: ${team})`

			console.log(`Changed to ${team} team`);


		})


		//Start screen mute button
		document.getElementById('muteButton').addEventListener('click', function () {
			isMuted = !isMuted;
			this.textContent = isMuted ? 'Unmute' : 'Mute';

			// Update mute state for intro video
			const introVideo = document.getElementById('introVideo');
			introVideo.muted = isMuted;

			// Update any currently playing videos in the video container
			const videoContainer = document.getElementById('videoContainer');
			const activeVideos = videoContainer.getElementsByTagName('video');
			for (let video of activeVideos) {
				video.muted = isMuted;
			}
		});

		document.querySelectorAll(".infoButton").forEach(button => {
			InfoTab = document.getElementById("GameInfo");
			GameScreen = document.getElementById('GameScreen');
			StartScreen = document.getElementById("StartScreen");
			Back = document.getElementById("backButton");
			button.addEventListener("click", function () {
				if (StartScreen.classList.contains("hidden")) {
					Back.innerHTML = "Back to Game"
					GameScreen.classList.add("hidden");
					hidden = "GameScreen";

				}
				else if (GameScreen.classList.contains("hidden")) {
					Back.innerHTML = "Back to Start Screen"
					StartScreen.classList.add("hidden");
					hidden = "StartScreen";
				}
				InfoTab.classList.remove("hidden");
			});
		});

		document.getElementById('backButton').addEventListener("click", function () {
			InfoTab = document.getElementById("GameInfo");
			StartScreen = document.getElementById('StartScreen');
			GameScreen = document.getElementById("GameScreen");
			if (hidden === "GameScreen") {
				GameScreen.classList.remove("hidden");
			}
			else if (hidden === "StartScreen") {
				StartScreen.classList.remove("hidden");
			}
			InfoTab.classList.add("hidden");
			hidden = "";

		})

		//Can also mute and unmute audio by pressing m on the keyboard
		document.addEventListener("keydown", function (event) {
			if (event.key == "m" || event.key === "M") {
				isMuted = !isMuted;
				document.getElementById('muteButton').textContent = isMuted ? 'Unmute' : 'Mute';

				const introVideo = document.getElementById('introVideo');
				introVideo.muted = isMuted;

				const videoContainer = document.getElementById('videoContainer');
				const activeVideos = videoContainer.getElementsByTagName('video');
				for (let video of activeVideos) {
					video.muted = isMuted;
				}
			}
			else if (event.key == "s" || event.key == "S") {
				SkipVideo();
			}
			else if (event.key == "h" || event.key == "H") {
				$("#gameId").toggle();
			}
		});

		document.addEventListener('DOMContentLoaded', function () {
			// Get all radio buttons in the victory conditions
			const radioButtons = document.querySelectorAll('input[name="victoryCommon"]');

			// Function to show the dropdown for the selected radio button and hide others
			function updateDropdowns() {
				// First, get all dropdown containers and hide them
				const dropdowns = document.querySelectorAll('.dropdown-container');
				dropdowns.forEach(dropdown => {
					dropdown.classList.remove('active');
				});

				// Find the selected radio button
				const selectedRadio = document.querySelector('input[name="victoryCommon"]:checked');
				if (selectedRadio) {
					// Get the selected value
					const selectedValue = selectedRadio.value;

					// Show the corresponding dropdown
					const selectedDropdown = document.getElementById(`${selectedValue}-dropdown`);
					if (selectedDropdown) {
						selectedDropdown.classList.add('active');
					}
				}
			}

			// Add change event listeners to all radio buttons
			radioButtons.forEach(radio => {
				radio.addEventListener('change', updateDropdowns);
			});

			// Initialize dropdowns based on the default selection
			updateDropdowns();
		});

		// Add this script to your document, preferably at the end before the closing body tag
		// document.addEventListener('DOMContentLoaded', function () {
		// 	// Get all tier checkboxes
		// 	const tierCheckboxes = document.querySelectorAll('.victory-item-tier input[type="checkbox"]');

		// 	// Add event listeners to each checkbox
		// 	tierCheckboxes.forEach(checkbox => {
		// 		checkbox.addEventListener('change', function () {
		// 			const currentTier = parseInt(this.closest('.victory-item-tier').dataset.tier);

		// 			if (this.checked) {
		// 				// If checked, also check all higher tiers (lower numbers)
		// 				tierCheckboxes.forEach(cb => {
		// 					const cbTier = parseInt(cb.closest('.victory-item-tier').dataset.tier);
		// 					if (cbTier < currentTier) {
		// 						cb.checked = true;
		// 					}
		// 				});
		// 			} else {
		// 				// If unchecked, also uncheck all lower tiers (higher numbers)
		// 				tierCheckboxes.forEach(cb => {
		// 					const cbTier = parseInt(cb.closest('.victory-item-tier').dataset.tier);
		// 					if (cbTier > currentTier) {
		// 						cb.checked = false;
		// 					}
		// 				});
		// 			}
		// 		});
		// 	});
		// });

		// Initialize with all victory conditions active and load from backend if available
		document.addEventListener('DOMContentLoaded', function () {
			// First try to load from backend
			loadVictoryConditions();

			// Set up event listeners
			setupEventListeners();
		});

		// Function to set up all event listeners
		function setupEventListeners() {
			// Add event listener to the save button
			const saveButton = document.getElementById('saveVictoriesBtn');
			if (saveButton) {
				saveButton.addEventListener('click', function () {
					updateActiveVictories();
					saveVictoryConditionsToBackend();
					showSaveConfirmation();
				});
			}

			// Add event listeners to all radio buttons to track changes in real-time
			const radioButtons = document.querySelectorAll('input[type="radio"]');
			radioButtons.forEach(radioButton => {
				radioButton.addEventListener('change', function () {
					// Automatically update active selection when a radio button changes
					updateActiveSelection();
					// If you want to save automatically on every change, uncomment this:
					saveSelectionToBackend();
				});
			});
		}

		// Function to update the active selection without displaying it
		function updateActiveSelection() {
			const form = document.getElementById('victoryForm');
			activeSelection = {};

			// Get all radio button groups by name
			const radioGroups = {};
			for (const radio of form.elements) {
				if (radio.type === 'radio') {
					if (!radioGroups[radio.name]) {
						radioGroups[radio.name] = [];
					}
					radioGroups[radio.name].push(radio);
				}
			}

			// Store the selected option for each radio group
			for (const [groupName, radios] of Object.entries(radioGroups)) {
				// Find the selected radio button in this group
				const selectedRadio = radios.find(radio => radio.checked);
				// Store the value of the selected radio button
				activeSelection[groupName] = selectedRadio ? selectedRadio.value : null;
			}

			// For debugging - you can remove this in production
			console.log('Active Selection:', activeSelection);
			return activeSelection;
		}

		// Function to show save confirmation message
		function showSaveConfirmation() {
			const confirmation = document.getElementById('saveConfirmation');
			if (confirmation) {
				confirmation.classList.add('show');
				// Hide the confirmation after 2 seconds
				setTimeout(() => {
					confirmation.classList.remove('show');
				}, 2000);
			}
		}

		// Function to get selection status programmatically (for your game code)
		function getSelectionStatus() {
			return activeSelection;
		}

		// Function to save selection to the backend
		function saveSelectionToBackend() {
			// Send data to the backend using jQuery AJAX
			$.ajax({
				url: '/api/selection/save',
				type: 'POST',
				contentType: 'application/json',
				data: JSON.stringify({ selection: activeSelection }),
				success: function (data) {
					console.log('Backend save success:', data);
					// Success is handled by showSaveConfirmation() if called together
				},
				error: function (xhr, status, error) {
					console.error('Error saving selection to backend:', error);
					// You might want to show an error message to the user
				}
			});
		}

		// Function to load saved selection from the backend
		function loadSelection() {
			fetch('/api/selection/get')
				.then(response => response.json())
				.then(data => {
					const form = document.getElementById('victoryForm');
					if (Object.keys(data).length > 0) {
						// We have saved data, update radio buttons
						for (const [groupName, selectedValue] of Object.entries(data)) {
							if (selectedValue) {
								const radio = form.querySelector(`input[name="${groupName}"][value="${selectedValue}"]`);
								if (radio) {
									radio.checked = true;
								}
							}
						}
						// Update our active selection object with loaded data
						activeSelection = data;
						console.log('Loaded selection from backend:', activeSelection);
					} else {
						// No saved data, initialize with current form values
						updateActiveSelection();
					}
				})
				.catch(error => {
					console.error('Error loading selection from backend:', error);
					// Fall back to using the current form values
					updateActiveSelection();
				});
		}

		// Optional: Function to check if backend is available
		function isBackendAvailable() {
			return fetch('/api/victory/health', { method: 'GET' })
				.then(response => response.ok)
				.catch(() => false);
		}

		//Plays preloaded intro video, initializes game, and unhides all elements that were previously hidden that are needed for the game. -Darin
		function StartGame() {
			setCanvasWidthandHeight();
			canvas.clear();
			setLengthandHeight();
			playIntroVideo();
			initializeGame();

			const selectedVictory = document.querySelector('input[name="victoryCommon"]:checked');
			const victoryType = selectedVictory ? selectedVictory.value : null;

			const inputData = {};
			if (victoryType) {
				const container = document.getElementById(victoryType + '-dropdown');
				if (container) {
					const inputs = container.querySelectorAll('input[type="number"]');
					inputs.forEach(input => {
						inputData[input.name] = parseInt(input.value);
					});
				}
			}

			//This was sending the glorious victories over but not we dont need this probably.
			// const tiers = [];
			// document.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
			// 	tiers.push(checkbox.name);
			// });

			const requestData = {
				victoryType: victoryType,
				parameters: inputData
				//selectedTiers: tiers
			};

			$.ajax({
				url: 'api/games',
				type: 'POST',
				contentType: 'application/json',
				dataType: 'text',
				data: JSON.stringify(requestData),
				success: function (resp) {
					$('#gameId').val(resp);
				},
				error: function () {
					alert('Network communication error');
				}
			});

			document.getElementById("GameScreen").classList.remove("hidden");
		}

		//Function to skip videos when called 
		function SkipVideo() {
			const videoContainer = document.getElementById('videoContainer');
			if (videoContainer.innerHTML != "") {
				videoContainer.innerHTML = "";
				videoContainer.style.pointerEvents = 'none';
				cont = true;
			}
			else {
				console.log("No video to skip")
			}
		}

		// Load board background
		function loadBoardBackground() {
			return new Promise((resolve, reject) => {
				//Loading the board image seems to work correctly
				fabric.Image.fromURL(THEMES[currentTheme].board/*'Images/HUNT-Pieces/HUNT-NewBoard-01.png'*/, function (boardImage) {
					boardImage.set({
						selectable: false,
						evented: false,
						left: 0,
						top: 0,
						scaleX: CANVAS_WIDTH / boardImage.width,
						scaleY: CANVAS_HEIGHT / boardImage.height
					});


					if (team === "White") {
						boardImage.set({
							angle: 180,
							left: CANVAS_WIDTH,
							top: CANVAS_HEIGHT
						});
					} else {
						boardImage.set({
							angle: 0,
							left: 0,
							top: 0
						});
					}

					canvas.insertAt(boardImage, 0);
					resolve(boardImage);
				}, function (error) {
					console.error('Failed to load board image:', error);
					reject(error);
				});
			});
		}

		function loadPieceImage(piece) {
			return new Promise((resolve, reject) => {
				// Determine color and type
				const isWhite = piece === piece.toUpperCase();
				const baseType = piece[0].toLowerCase();
				let value = piece.slice(1);

				// Construct dynamic image path
				let imagePath;
				if (baseType == 'p') {
					imagePath = isWhite ? THEMES[currentTheme].pieces.whitePyramid : THEMES[currentTheme].pieces.blackPyramid;
					value = isWhite ? ['c1', 'c4', 't9', 't16', 's25', 's36'] : ['C16', 'T25', 'T36', 'S49', 'S64'];
				} else {
					// Use the theme's pieceFormat function for regular pieces (This Should fix it)
					imagePath = THEMES[currentTheme].pieces.pieceFormat(value, isWhite, baseType);


				}

				fabric.Image.fromURL(imagePath, function (img) {
					img.set({
						left: 0, // Will be set during board setup
						top: 0,
						originX: 'center',
						originY: 'center',
						//Scale seems to be way too big for piece scale -Fixed?
						scaleX: THEMES[currentTheme].pieceScale.x * length / img.width,
						scaleY: THEMES[currentTheme].pieceScale.y * height / img.height,
						hasControls: false,
						hasBorders: false,
						selectable: true,
						pieceColor: isWhite ? 'white' : 'black',
						pieceType: baseType,
						pieceValue: value
					});

					resolve(img);
				}, function (error) {
					console.error(`Failed to load image for piece ${piece}:`, error);
					reject(error);
				});
			});
		}

		async function addPieces() {
			//2 Board initial states for the different player team cases. Darin
			const initialBoardState = team === "Black" ? [
				['s49', 's28', 't16', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'T81', 'S153', 'S289'],
				['s121', 's66', 't36', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'T49', 'P', 'S169'],
				['.', 't12', 'c9', 'c3', '.', '.', '.', '.', '.', '.', '.', '.', 'C8', 'C64', 'T72', '.'],
				['.', 't30', 'c25', 'c5', '.', '.', '.', '.', '.', '.', '.', '.', 'C6', 'C36', 'T42', '.'],
				['.', 't56', 'c49', 'c7', '.', '.', '.', '.', '.', '.', '.', '.', 'C4', 'C16', 'T20', '.'],
				['.', 't90', 'c81', 'c9', '.', '.', '.', '.', '.', '.', '.', '.', 'C2', 'C4', 'T6', '.'],
				['s225', 's120', 't64', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'T25', 'S45', 'S81'],
				['s361', 'p', 't100', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'T9', 'S15', 'S25']
			] : [
				['S25', 'S15', 'T9', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't100', 'p', 's361'],
				['S81', 'S45', 'T25', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't64', 's120', 's225'],
				['.', 'T6', 'C4', 'C2', '.', '.', '.', '.', '.', '.', '.', '.', 'c9', 'c81', 't90', '.'],
				['.', 'T20', 'C16', 'C4', '.', '.', '.', '.', '.', '.', '.', '.', 'c7', 'c49', 't56', '.'],
				['.', 'T42', 'C36', 'C6', '.', '.', '.', '.', '.', '.', '.', '.', 'c5', 'c25', 't30', '.'],
				['.', 'T72', 'C64', 'C8', '.', '.', '.', '.', '.', '.', '.', '.', 'c3', 'c9', 't12', '.'],
				['S169', 'P', 'T49', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't36', 's66', 's121'],
				['S289', 'S153', 'T81', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't16', 's28', 's49']
			];

			$.ajax({
				url: 'api/games',
				type: 'POST',
				contentType: 'application/json',
				dataType: 'text',
				data: JSON.stringify(initialBoardState),
				success: function (resp) {
					$('#gameId').val(resp);
				},
				error: function () {
					alert('Network communication error');
			}

			const pieceLoadPromises = [];

			for (let rowIndex = 0; rowIndex < initialBoardState.length; rowIndex++) {
				for (let colIndex = 0; colIndex < initialBoardState[rowIndex].length; colIndex++) {
					let piece = initialBoardState[rowIndex][colIndex];

					if (piece !== '.') {
						const piecePromise = loadPieceImage(piece).then(pieceObject => {
							// Position the piece
							pieceObject.set({
								//Height and length seem to be off and test 3 has height and length flipped
								left: colIndex * height + height / 2 + THEMES[currentTheme].pieceOffset.left,
								top: rowIndex * length + length / 2 + THEMES[currentTheme].pieceOffset.top
							});

							boardState[rowIndex][colIndex] = pieceObject;
							canvas.add(pieceObject);
							if (pieceObject.pieceType == 'p') {
								updatePyramid(pieceObject.pieceColor, pieceObject.pieceValue);
							}
						});
						pieceLoadPromises.push(piecePromise);
					}
				};
			};
			// Wait for all pieces to be loaded before resolving
			await Promise.all(pieceLoadPromises);
		}

		//Made a play intro function for an easy access way to play the intro video without rewritting the playVideo function. -Darin
		function playIntroVideo() {
			const videoContainer = document.getElementById('videoContainer');

			videoContainer.innerHTML = '';
			videoContainer.style.pointerEvents = 'auto';

			const video = document.getElementById('introVideo');
			video.autoplay = true;
			video.loop = false;
			video.controls = false;
			video.muted = isMuted;

			videoContainer.appendChild(video);
			video.style.display = "block";
			video.play();

			video.addEventListener('ended', () => {
				videoContainer.innerHTML = '';
				videoContainer.style.pointerEvents = 'none';
			});
		}

		function playVideo(vid) {
			cont = false;
			const videoContainer = document.getElementById('videoContainer');

			videoContainer.innerHTML = '';
			videoContainer.style.pointerEvents = 'auto';

			const video = document.createElement('video');
			video.src = vid;
			video.autoplay = true;
			video.loop = false;
			video.controls = false;
			video.muted = isMuted;

			videoContainer.appendChild(video);

			video.addEventListener('ended', () => {
				let opacity = 1;
				const fadeInterval = setInterval(() => {
					if (opacity > 0) {
						opacity -= 0.01;
						video.style.opacity = opacity;
					} else {
						clearInterval(fadeInterval); // Stop fading when opacity reaches 0
					}
				}, 10); // Adjust the interval for speed
				setTimeout(function () {
					cont = true;
				}, 500);
				videoContainer.style.pointerEvents = 'none';
			});
		}

		function updatePyramid(w, ary) {
			// Determine if it's the white pyramid
			const isWhite = w === "white";

			// Get the appropriate div element
			const divElement = document.getElementById(isWhite ? "white-pyramid" : "black-pyramid");

			// Update the div with the heading and array content
			divElement.innerHTML = `
					<h3>${isWhite ? "White Pyramid" : "Black Pyramid"}</h3>
					${ary.map(item => `<p>${item}</p>`).join("")}
					`;

		}


		let gridObjects = [];
		//Only creates a proper grid for Lulu's board. Is toggleable with G. -Darin
		function createGrid() {
			if (gridObjects.length > 0) {
				// If grid exists, remove it
				gridObjects.forEach(obj => canvas.remove(obj));
				gridObjects = []; // Clear the stored grid objects
				canvas.renderAll();
				return; // Exit function since we just removed the grid
			}

			const rows = 8;
			const cols = 16;
			const alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];

			for (let row = 0; row < rows; row++) {
				for (let col = 0; col < cols; col++) {
					const centerX = col * length + length / 2 + THEMES[currentTheme].gridOffset.centerX;
					const centerY = row * height + height / 2 + THEMES[currentTheme].gridOffset.centerY;

					// Create grid square
					const rect = new fabric.Rect({
						left: centerX - length / 2,
						top: centerY - height / 2,
						width: length,
						height: height,
						fill: 'transparent',
						strokeWidth: 1,
						stroke: 'red',
						selectable: false,
						evented: false
					});

					// Determine algebraic notation
					const file = alphabet[row];
					const rank = col + 1;
					const algebraicNotation = `${file}${rank}`;

					// Create notation text
					const text = new fabric.Text(algebraicNotation, {
						left: centerX,
						top: centerY,
						fontSize: 12,
						fontFamily: 'Arial',
						fill: 'rgba(0, 0, 0, 0.5)',
						originX: 'center',
						originY: 'center',
						selectable: false,
						evented: false
					});

					// Add objects to canvas and store them
					canvas.add(rect);
					canvas.add(text);
					gridObjects.push(rect, text);
				}
			}

			canvas.renderAll();
		}


		function movePiece(from, to) {

			// Convert from algebraic notation to row and column
			function positionToIndices(position) {
				let c = position.toUpperCase().charCodeAt(0) - 65;
				let r = Number(position[1]) - 1;
				if (position[2]) {
					r = Number(position[1] + position[2]) - 1;
				}
				return { c, r };
			}

			const fromIndices = positionToIndices(from);
			const toIndices = positionToIndices(to);

			// Find the piece at the 'from' position (e.g., C4)
			const piece = boardState[fromIndices.c][fromIndices.r];

			if (piece) {
				// Calculate the target position (center of the square in grid)
				const targetCenterX = toIndices.r * height + height / 2 + THEMES[currentTheme].gridOffset.centerX;
				const targetCenterY = toIndices.c * length + length / 2 + THEMES[currentTheme].gridOffset.centerY;

				// Animate the piece to the target position with smooth transition
				piece.animate({
					left: targetCenterX,
					top: targetCenterY
				}, {
					duration: 1000, // Duration of the animation in milliseconds (adjust as needed)
					onChange: canvas.renderAll.bind(canvas), // Re-render the canvas during animation
					easing: fabric.util.ease.easeInOutQuad, // Smooth easing function
					onComplete: function () {
						// After the animation completes, update the piece position in the boardState
						boardState[fromIndices.c][fromIndices.r] = null;
						boardState[toIndices.c][toIndices.r] = piece;

						console.log(`Piece moved from ${from} to ${to}`);
					}
				});

			} else {
				console.log(`No piece found at ${from}`);
			}
		}

		function capturePiece(position, value, type) {
			switch (type) {
				//Fixed
				case "s":
					playVideo(THEMES[currentTheme].videos.siege(team));
					break;
				case "n":
					playVideo(THEMES[currentTheme].videos.encounter(team));
					break;
				case "r":
					playVideo(THEMES[currentTheme].videos.eruption(team));
					break;
				case "d":
					playVideo(THEMES[currentTheme].videos.deceit(team));
					break;
			}
			for (let i = 0; i < position.length; i++) {
				const c = position[i].toUpperCase().charCodeAt(0) - 65;
				const r = Number(position[i].slice(1)) - 1;

				// Find the piece at the specified position
				const piece = boardState[c][r];

				if (piece) {
					if (Array.isArray(piece.pieceValue)) {
						let index = piece.pieceValue.indexOf(value[i]);
						piece.pieceValue.splice(index, 1);
						updatePyramid(piece.pieceColor, piece.pieceValue);
						if (piece.pieceValue.length == 0) {
							piece.animate({ opacity: 0 }, {
								duration: 500,
								onChange: canvas.renderAll.bind(canvas),
								onComplete: () => {
									canvas.remove(piece);
									boardState[c][r] = null; // Clear the captured position
									console.log(`Pyramid at ${position[i]} empty.`);
								}
							});
						};
					}
					else {
						piece.animate({ opacity: 0 }, {
							duration: 500,
							onChange: canvas.renderAll.bind(canvas),
							onComplete: () => {
								canvas.remove(piece);
								boardState[c][r] = null; // Clear the captured position
								console.log(`Piece at ${position[i]} captured.`);
							}
						});
					}

				} else {
					console.log(`No piece found at ${position[i]} to capture.`);
				}
			}
		}

		function enableSnapping() {
			const rows = 8;
			const cols = 16;

			// Snap based on the closest grid center
			canvas.on('object:moving', function (event) {
				const obj = event.target;

				// Get the current mouse position
				const pointer = canvas.getPointer(event.e);

				// Variables to track the closest grid square
				let closestLeft = 0;
				let closestTop = 0;
				let smallestDistance = Infinity;

				let oldRowIndex = -1;
				let oldColIndex = -1;

				// Iterate over all grid square centers to find the closest
				for (let row = 0; row < rows; row++) {
					for (let col = 0; col < cols; col++) {
						// Calculate the center of the current grid square
						const gridCenterX = col * height + height / 2 + THEMES[currentTheme].gridOffset.centerX;
						const gridCenterY = row * length + length / 2 + THEMES[currentTheme].gridOffset.centerY;

						// Calculate the distance between the mouse pointer and the grid center
						const distance = Math.sqrt(
							Math.pow(pointer.x - gridCenterX, 2) + Math.pow(pointer.y - gridCenterY, 2)
						);

						// Update the closest grid square if this one is closer
						if (distance < smallestDistance) {
							smallestDistance = distance;
							closestLeft = gridCenterX;
							closestTop = gridCenterY;

							// Track the closest grid position (row, col)
							oldRowIndex = row;
							oldColIndex = col;
						}
					}
				}

				// Update the piece's position to the closest grid square center
				obj.left = closestLeft;
				obj.top = closestTop;

				// Remove the piece from the old position in boardState
				if (oldRowIndex !== -1 && oldColIndex !== -1) {
					boardState[oldRowIndex][oldColIndex] = null; // Clear the old position
				}

				// Calculate new row and column indices based on the snapped position
				const newRowIndex = Math.floor((closestTop - /*These 2 numbers are different between tests ->*/ 20) / length);
				const newColIndex = Math.floor((closestLeft - 125 / 4) / height);

				// Add the piece to the new position in boardState
				if (newRowIndex >= 0 && newRowIndex < rows && newColIndex >= 0 && newColIndex < cols) {
					boardState[newRowIndex][newColIndex] = obj; // Place the piece at the new position
				}
			});
		}

		function handleFileUpload(event) {
			stopExecution = false;
			const file = event.target.files[0];
			if (file) {
				//Swapped fuction specific reader for the global reader so it can be stopped at will. -Darin
				currentFileReader = new FileReader();
				currentFileReader.onload = function (e) {
					const fileContent = e.target.result;
					const moves = parseMoves(fileContent);
					resetGame().then(() => {
						executeMoves(moves);
					}).catch(error => {
						console.error('Error resetting the game:', error);
					})
				};
				currentFileReader.readAsText(file);
			}
		}

		function parseMoves(fileContent) {
			// Split the file content by lines
			const lines = fileContent.split('\n');
			const moves = [];

			lines.forEach(line => {
				if (line.trim()) {
					const movePairs = line.split(' '); // Split by space
					movePairs.forEach(pair => {
						if (pair.toUpperCase().includes('X')) {
							// Handle capture move (e.g., A1A2xC4c9)
							const parts = pair.split('x'); // Split by 'x'
							let [move, ...captures] = parts;
							const c = captures[0].match(/([snrd])(.*)/i);
							console.log(c);
							captures[0] = c[2];
							let take = [];
							let ids = [];

							// Extract capture position and unique ID (e.g., "C4" and "c9")
							captures.forEach(cap => {
								const captureMatch = cap.match(/([A-H][0-9]*)([c,t,s,C,T,S]\d+)/i);
								take.push(captureMatch[1]); // Capture position (e.g., "C4")
								ids.push(captureMatch[2]); // Captured piece info (e.g., "c9")
							});

							const [from, to] = splitMove(move); // Split the move into 'from' and 'to'
							moves.push([from, to, take, ids, c[1]]); // Add the parsed capture
						} else if (pair.length >= 4) {
							// Handle regular move (e.g., A1A2)
							const [from, to] = splitMove(pair);
							moves.push([from, to]); // Add regular move
						}
					});
				}
			});
			return moves;
		}


		// Helper function to split a move into from and to
		function splitMove(move) {
			let from;
			let to;
			if (isNaN(move.charAt(2))) {
				from = move.slice(0, 2);
				to = move.slice(2);
			}
			else {
				from = move.slice(0, 3);
				to = move.slice(3);
			}
			return [from, to]; // Return the from and to positions
		}


		function executeMoves(moves) {

			let index = 0;

			function playNextMove() {
				if (stopExecution) {
					console.log("Move execution stopped.");
					return;
				}
				if (index < moves.length) {
					if (cont) {
						const move = moves[index];
						const from = move[0]; // Starting position
						const to = move[1];   // Target position
						const captures = move[2] || null; // Optional capture position

						// Perform the move
						movePiece(from, to);

						// Handle capture if specified
						if (captures) {
							setTimeout(() => {
								capturePiece(captures, move[3], move[4]);
							}, 1100); // Slight delay to align with move animation
						}

						// Wait before moving to the next move
						setTimeout(() => {
							index++;
							playNextMove();

						}, 2000); // Adjust delay as needed
					} else {
						setTimeout(playNextMove, 1000);
					}
				} else {
					setTimeout(() => {
						resetGame().then(() => {
							if (isLooping) {
								executeMoves(moves);
							} else {
								isLooping = true
								document.getElementById('moveFileInput').value = '';
							}
						}).catch(error => {
							console.error('Error resetting the game:', error);
						})

					}, 1000);

				}
			}

			playNextMove(); // Start executing moves
		}

		function StopFileExecution() {
			currentFileReader = null;
			stopExecution = true;
			isLooping = false;
		}

		function resetGame() {
			return new Promise((resolve, reject) => {
				// Clear all objects on the canvas
				canvas.clear();

				// Reset the board state to empty
				boardState = Array(8).fill().map(() => Array(16).fill(null));

				// Reload the board background
				loadBoardBackground().then(() => {

					// Wait for addPieces to finish loading the pieces before resolving the promise
					addPieces().then(() => {
						resolve(); // Resolve the promise once all pieces are loaded
					}).catch((error) => {
						console.error('Error loading pieces:', error);
						reject(error); // Reject if there's an error loading pieces
					});
				}).catch((error) => {
					console.error('Error loading board background:', error);
					reject(error); // Reject if there's an error loading the board background
				});

			});
		}

		function handleReset() {
			resetGame().then(() => {
				StopFileExecution();
				document.getElementById('moveFileInput').value = '';
			}).catch(error => {
				console.error("Error during reset:", error);
			});
		}

		// Initialize the game
		async function initializeGame() {
			try {

				// Load the background image first
				await loadBoardBackground();

				await addPieces();

				enableSnapping();
				canvas.renderAll();
			} catch (error) {
				console.error('Game initialization failed:', error);
			}
		}

		function PauseButton() {
			const button = document.getElementById("pause");
			// Change the button text to a new value
			if (button.innerHTML === "Pause") {
				button.innerHTML = "Play";
				cont = false;
			} else {
				button.innerHTML = "Pause";
				cont = true;
			}
		}

		//Toggle for grid -Darin 
		document.addEventListener("keydown", (event) => {
			if (event.key === "g" || event.key === "G") {
				createGrid();
			}
		});

		document.getElementById('moveFileInput').replaceWith(document.getElementById('moveFileInput').cloneNode(true));
		document.getElementById('moveFileInput').addEventListener('change', handleFileUpload);
	</script>
</body>

</html>
