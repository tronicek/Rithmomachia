<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Rithmomachia</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap');

		body {
			margin: 0;
			padding: 20px;
			background-color: #533c3c;
		}

		.overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.0);
			z-index: 9999;
			pointer-events: none;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		video {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}

		.container {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 20px;
			height: 91vh;
			max-width: 1200px;
			margin: 0 auto;
			position: relative;
		}

		.title {
			font-family: 'Playfair Display', serif;
			font-size: 48px;
			font-weight: 600;
			width: 350px;
			padding: 15px;
			margin: 0px;
			text-align: center;
			background-color: #620404;
			border-radius: 100px;
			color: #000000;
		}

		.game-controls {
			position: absolute;
			top: 20px;
			right: 2.5%;
			/* Indicates the percentage/pixles from the right side of the area it resides in*/
			display: flex;
			flex-direction: row;
			gap: 10px;
			z-index: 100;
			max-width: calc(31%);
			/* Width limited to avoid reaching the title */
			flex-wrap: wrap;
			justify-content: flex-start;
			align-items: center;
		}

		.game-container {
			display: flex;
			gap: 20px;
			width: 100%;
			justify-content: center;
		}

		.custom-file-label {
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			display: inline-block;
			border-radius: 10px;
		}

		#black-pyramid {
			background-color: black;
			color: white;
			border-radius: 5px;
			text-justify: inter-word;
			text-align: center;
			height: 300px;
			min-width: 85px;
			width: 85px;
			/* Added order attribute for team change functionality and moving the pyramid display Darin*/
			order: -1;
		}

		#white-pyramid {
			background-color: white;
			color: black;
			border-radius: 5px;
			text-align: center;
			height: 300px;
			min-width: 85px;
			width: 85px;
			/* Order here too Darin*/
			order: 1;
		}

		.game-controls button {
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			border-radius: 10px;
		}

		#game-board {
			position: relative;
			width: fit-content;
			max-width: 1000px;
			max-height: 500;
			border: 2px solid #333;
			border-radius: 8px;
			overflow: hidden;
		}

		#gameCanvas {
			position: absolute;
			top: 0;
			left: 0;
		}

		#StartScreen {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			position: relative;
			width: 1000px;
			height: 800px;
			border-radius: 20px;
			padding: 20px;
			overflow: hidden;
		}

		#SetupScreen {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			position: relative;
			width: 1000px;
			height: 800px;
			border-radius: 20px;
			padding: 20px;
			overflow: hidden;
		}

		#SetupScreen h2 {
			color: black;
			text-align: center;
			text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
			position: relative;
			z-index: 2;
			/* Keeps it above the background */
			margin-top: 20px;
			/* Adds space below the title */
			/* If needed, you could also use padding-top instead */
		}

		.victory-list {
		      list-style-type: none;
		      padding: 0;
		      display: grid;
		      grid-template-columns: 1fr 1fr;
		      gap: 10px;
		}

		.victory-item {
			margin-bottom: 5px;
			padding: 10px;
			border: 1px solid #666666;
			border-radius: 5px;
			background-color: #888888;
			transition: background-color 0.3s;
		}

		.victory-item:hover {
			background-color: #999999;
		}

		.victory-item label {
			display: flex;
			align-items: center;
			cursor: pointer;
		}

		.save-confirmation {
		    color: #4CAF50;
		    font-weight: bold;
		    opacity: 0;
		    transition: opacity 0.3s ease;
		    margin: 10px 0;
		    text-align: center;
		}
		
		.save-confirmation.show {
		    opacity: 1;
		}

		/* Added to flip background without flipping the entire start screen Darin */
		#backgroundWrapper {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			/* Unneeded. Background wrapper switches regardless of what is listed here. Should only be a static background image before the user switches it. */
			background-image:
			/*`url(${THEMES[currentTheme].board})`*/
			url('Images/HUNT-Pieces/HUNT-NewBoard-01.png');
			background-size: cover;
			background-position: center;
			transition: transform 0.5s ease;
			transform-origin: center center;
		}

		/* Added a grouping of the start screen buttons to format instead of listing them individually. Also gave start screen buttons a hover effect Darin */
		#StartScreen button {
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			border-radius: 10px;
			font-size: 20px;
			margin: 10px 0;
			transform: rotate(0deg) !important;
			transition: background-color 0.3s ease;
			z-index: 1;
			width: 370px;
			height: 40px;
			text-align: center;
		}

		#SetupScreen button {
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			border-radius: 10px;
			font-size: 20px;
			margin: 10px 0;
			transform: rotate(0deg) !important;
			transition: background-color 0.3s ease;
			z-index: 999;
			width: 370px;
			height: 40px;
			text-align: center;
		}

		#StartScreen button:hover {
			background-color: #888888;
		}

		#StartScreen button:active {
			background-color: #666666;
		}


		.hidden {
			display: none !important;
		}

		#themeSelect {
			position: relative;
			z-index: 10;
			background-color: #777777;
			color: black;
			padding: 10px 20px;
			border: none;
			cursor: pointer;
			border-radius: 10px;
			font-size: 20px;
			margin: 10px 0;
			transform: rotate(0deg) !important;
			transition: background-color 0.3s ease;
			z-index: 1;
			width: 370px;
			height: 40px;
			text-align: center;
		}
	</style>
</head>

<body>
	<div class="container">
		<div class="overlay" id="videoContainer"></div>
		<h1 class="title">Rithmomachia</h1>
		<div id="StartScreen">
			<!-- Background wrapper for image of background board on start screen Darin -->
			<div id="backgroundWrapper"></div>
			<button id="startButton">Start Game</button>
			<button id="muteButton">Mute</button>
			<button id="teamChangeButton">Change Team (Current team: Black)</button>
			<button class="volumeButton">Volume</button>
			<button class="infoButton">Game Info</button>
			<select id="themeSelect" title="Theme">
				<option value="Daniel_Hunt">Daniel Theme</option>
				<option value="Lulu_Burkowski">Lulu Theme</option>
				<option value="Jessie_Reed">Jessie Theme</option>
			</select>
		</div>
		<div id="SetupScreen" class="hidden">
			<!-- //These Dont do anything for now but are here for in the future -->
			<h2>Victory Conditions</h2>
			<form id="victoryForm">
				<ul class="victory-list">
					<li class="victory-item">
						<label>
							<input type="checkbox" name="victoryBodies" checked> Victory of Bodies
						</label>
					</li>
					<li class="victory-item">
						<label>
							<input type="checkbox" name="victoryGoods" checked> Victory of Goods
						</label>
					</li>
					<li class="victory-item">
						<label>
							<input type="checkbox" name="victoryQuarrel" checked> Victory of Quarrel
						</label>
					</li>
					<li class="victory-item">
						<label>
							<input type="checkbox" name="victoryHonor" checked> Victory of Honor
						</label>
					</li>
					<li class="victory-item">
						<label>
							<input type="checkbox" name="victoryHonorQuarrel" checked> Victory of Honor and Quarrel
						</label>
					</li>
					<li class="victory-item">
						<label>
							<input type="checkbox" name="victoriaMagna" checked> Victoria Magna
						</label>
					</li>
					<li class="victory-item">
						<label>
							<input type="checkbox" name="victoriaMayor" checked> Victoria Mayor
						</label>
					</li>
					<li class="victory-item">
						<label>
							<input type="checkbox" name="victoriaExcelentisima" checked> Victoria Excelentisima
						</label>
					</li>
				</ul>
			</form>
			<button id="saveVictoriesBtn">Save Changes</button>
			<p id="saveConfirmation" class="save-confirmation">Victory conditions saved!</p>
			<button id="ContinueToGame">Continue</button>
		</div>
		<div class="game-controls">
			<label id="fileLabel" for="moveFileInput" class="custom-file-label hidden">Open File</label>
			<input type="file" id="moveFileInput" accept=".txt" style="display:none;" />
			<button id="endLoopButton" class="hidden" onclick="handleReset()">Reset</button>
			<button id="pause" onclick="PauseButton()" class="hidden">Pause</button>
			<button class="hidden" id="volumeButton">Volume</button>
			<button class="hidden infoButton" id="InfoButton">Game Info</button>
		</div>
		<div class="game-container">
			<div id="black-pyramid" class="hidden">
				<h3>Black<br />Pyramid</h3>
			</div>
			<div id="game-board" class="hidden">
				<canvas id="gameCanvas"></canvas>
			</div>
			<div id="white-pyramid" class="hidden">
				<h3>White<br />Pyramid</h3>
			</div>
		</div>
	</div>
	<!--Preload Intro video Darin-->
	<video id="introVideo" preload="auto" style="display: none;">
		<source src="Images/Rith/HUNTRithCutscene.mp4" type="video/mp4">
	</video>
	<input id="gameId" type="text" readonly size="40" />

	<script>
		let activeVictoryConditions = {};
		let isMuted = false;
		let currentFileReader = null;
		let currentTheme = "Daniel_Hunt";
		//Team variable used to determine which team the player is Darin
		let team = "Black";
		let CANVAS_WIDTH;
		let CANVAS_HEIGHT;
		let stopExecution = false;
		//Not in original main file but breaks code if removed.
		let length;
		let height;

		const THEMES = {
			Lulu_Burkowski: {
				board: 'Images/Rithmomachia/Board and pieces/Board-Rotate.png',
				pieces: {
					base: 'Images/Rithmomachia/Board and pieces',
					blackPyramid: 'Images/Rithmomachia/Board and pieces/Black_Pyramid.png',
					whitePyramid: 'Images/Rithmomachia/Board and pieces/White_Pyramid.png',
					pieceFormat: (value, isWhite, type) => `Images/rithmomachia/Board and pieces/${value}_${isWhite ? 'White' : 'Black'}_${{
						's': 'Square',
						't': 'Triangle',
						'c': 'Circle'
					}[type]
						}.png`
				},
				videos: {
					//Changed isWhite to act like the team variable. -Darin
					intro: `Images/Rithmomachia/captures and intro with sound/Intro.mp4`,
					siege: (/* type, */ isWhite) => `Images/rithmomachia/captures and intro with sound/Siege ${isWhite == "Black" ? 'black' : 'white'}.mp4`,
					encounter: (/* type, */ isWhite) => `Images/rithmomachia/captures and intro with sound/Encounter ${isWhite == "Black" ? 'black' : 'white'}.mp4`,
					eruption: (/* type, */ isWhite) => `Images/rithmomachia/captures and intro with sound/Eruption ${isWhite == "Black" ? 'black' : 'white'}.mp4`,
					deceit: (/* type, */ isWhite) => `Images/rithmomachia/captures and intro with sound/Deceit ${isWhite == "Black" ? 'black' : 'white'}.mp4`
				},
				//%scale, x is width of pieces and y is height
				pieceScale: {
					x: 0.75,
					y: 0.75
				},
				//This is the offset each piece is at
				pieceOffset: {
					left: 65 / 2,
					top: 31.25 / 2
				},
				//This is the size of the grid cells with length being x related and height being y related
				cellSize: {
					length: 58.4375,
					height: 58.59375
				},
				//Offset of grid for enable snapping and move piece
				gridOffset: {
					centerX: 125 / 4,
					centerY: 17
				},
				//Canvas dimensions for board
				canvasDim: {
					width: 1000,
					height: 500
				}

			},
			Jessie_Reed: {
				board: 'Images/Rithmomachia Art/Board.png',
				pieces: {
					base: 'Images/Rithmomachia Art/',
					whitePyramid: 'Images/Rithmomachia Art/White_Pyramid.png',
					blackPyramid: 'Images/Rithmomachia Art/Black_Pyramid.png',
					pieceFormat: (value, isWhite, type) => `Images/rithmomachia Art/${value}_${isWhite ? 'White' : 'Black'}_${{
						's': 'Square',
						't': 'Triangle',
						'c': 'Circle',
					}[type]
						}.png`
				},
				videos: {
					intro: 'Images/Rithmomachia Art/Intro final animation with sound.MP4',
					siege: (isWhite) => 'Images/Rithmomachia Art/Siege final draft with sound.MP4',
					encounter: (isWhite) => 'Images/Rithmomachia Art/Encounter final draft with sound.MP4',
					eruption: (isWhite) => 'Images/Rithmomachia Art/Eruption final draft with sound.MP4',
					deceit: (isWhite) => 'Images/Rithmomachia Art/Deceit final draft with sound.MP4'
				},
				pieceScale: {
					x: .94,
					y: .82
				},
				pieceOffset: {
					left: 71,
					top: 71
				},
				cellSize: {
					length: 680 / 16,
					height: 392 / 8
				},
				gridOffset: {
					centerX: 71,
					centerY: 71
				},
				canvasDim: {
					width: 925,
					height: 480
				}

			},
			Daniel_Hunt: {
				board: 'Images/HUNT-Pieces/HUNT-NewBoard-01.png',
				pieces: {
					base: 'Images/HUNT-Pieces/',
					whitePyramid: 'Images/HUNT-Pieces/StackWhite.png',
					blackPyramid: 'Images/HUNT-Pieces/StackBrown.png',
					pieceFormat: (value, isWhite, type) => `Images/HUNT-Pieces/${{
						's': 'Sq',
						't': 'Tri',
						'c': 'Circ'
					}[type]
						}${value}.png`
				},
				videos: {
					intro: 'Images/Rith/HUNTRithCutscene.mp4',
					siege: (isWhite) => 'Images/Rith/Siege Video.mp4',
					encounter: (isWhite) => 'Images/Rith/Encounter Video.mp4',
					eruption: (isWhite) => 'Images/Rith/Eruption Video.mp4',
					deceit: (isWhite) => 'Images/Rith/Deceit Video.mp4'
				},
				pieceScale: {
					x: 0.76,
					y: 0.76
				},
				pieceOffset: {
					left: 92.75,
					top: 75
				},
				cellSize: {
					length: 41,
					height: 46
				},
				gridOffset: {
					centerX: 95,
					centerY: 77
				},
				canvasDim: {
					width: 925,
					height: 480
				}

			}
		};

		// Theme switching functionality
		document.getElementById('themeSelect').addEventListener('change', (e) => {
			currentTheme = e.target.value;
			console.log(currentTheme);

			//Loads intro depending on theme
			let video = document.getElementById('introVideo');
			let source = video.querySelector('source');
			source.src = THEMES[currentTheme].videos.intro;
			video.load();

			//Changes body background if the theme is jessie's as test 2 has a special image for it. 
			if (currentTheme == "Jessie_Reed") {
				document.body.style.backgroundImage = "url('Images/Rithmomachia Art/Background.jpg')";
			}
			else {
				document.body.style.backgroundImage = "none";
			}

			// Only reset the game if it's already started
			if (!document.getElementById('StartScreen').classList.contains('hidden')) {
				updateBackgroundWrapper();
			} else {
				resetGame();
			}
		});

		//Updates start screen background board 
		function updateBackgroundWrapper() {
			const backgroundWrapper = document.getElementById('backgroundWrapper');
			backgroundWrapper.style.backgroundImage = `url('${THEMES[currentTheme].board}')`;
		}

		// Initialize canvas with proper dimensions
		const canvas = new fabric.Canvas('gameCanvas', {
			// width: CANVAS_WIDTH,
			// height: CANVAS_HEIGHT,
			selection: false,
			renderOnAddRemove: true
		});
		//Helper function to set canvas width and height with theme
		function setCanvasWidthandHeight() {
			CANVAS_WIDTH = THEMES[currentTheme].canvasDim.width;
			CANVAS_HEIGHT = THEMES[currentTheme].canvasDim.height;
			canvas.setWidth(CANVAS_WIDTH);
			canvas.setHeight(CANVAS_HEIGHT);
		}

		//Check that intro video is loaded in console -Darin
		const introVideo = document.getElementById("introVideo");
		introVideo.oncanplaythrough = () => {
			console.log("Intro video is preloaded and ready.");
		};

		//Helper function for the cell length and height to set dynamically with theme
		function setLengthandHeight() {
			length = THEMES[currentTheme].cellSize.length;
			height = THEMES[currentTheme].cellSize.height;
		}

		let boardState = Array(8).fill().map(() => Array(16).fill(null));
		let isLooping = true;
		let cont = true;

		//When start button is clicked it hides itself and calls start game -Darin
		document.getElementById('startButton').addEventListener('click', function () {
			document.getElementById('StartScreen').classList.add('hidden');
			document.getElementById('muteButton').classList.add('hidden');
			document.getElementById('SetupScreen').classList.remove('hidden');
			//StartGame();
		});

		document.getElementById('ContinueToGame').addEventListener('click', function () {
			document.getElementById('SetupScreen').classList.add('hidden');
			StartGame();
		});


		//Function for the team change button. Once pressed behind the scenes the board and pieces are swapped and visually the button changes the current team and the background of start screen flips. Darin
		document.getElementById('teamChangeButton').addEventListener('click', function () {
			const backgroundWrapper = document.getElementById('backgroundWrapper');

			let Black_Pyramid = document.getElementById("black-pyramid");
			let White_Pyramid = document.getElementById("white-pyramid");

			let BlackOrder = window.getComputedStyle(Black_Pyramid).order;
			let WhiteOrder = window.getComputedStyle(White_Pyramid).order;

			Black_Pyramid.style.order = WhiteOrder;
			White_Pyramid.style.order = BlackOrder;

			team = team === "Black" ? "White" : "Black";

			//Different animations for each board when the team is switched 
			if (currentTheme == "Daniel_Hunt") {
				backgroundWrapper.style.transform = `scaleX(${team === "White" ? -1 : 1})`;
			}
			else if (currentTheme == "Jessie_Reed") {
				backgroundWrapper.style.transition = "transform 1s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
				backgroundWrapper.style.transform = `rotate(${team === "White" ? 300 : -120}deg)`;

				setTimeout(() => {
					backgroundWrapper.style.transform = `scaleX(${team === "White" ? -1 : 1})`;
				}, 500);
			}
			else if (currentTheme == "Lulu_Burkowski") {
				backgroundWrapper.style.transition = "transform 1s ease-in-out, scale 0.6s ease-in-out";
				backgroundWrapper.style.transform = "scale(0.7) rotate(360deg)"; // Added rotation

				setTimeout(() => {
					backgroundWrapper.style.transform = "scale(1.1) rotate(0deg)";
				}, 300);

				setTimeout(() => {
					backgroundWrapper.style.transform = `scaleX(${team === "White" ? -1 : 1})`;
				}, 600);
			}



			this.textContent = `Change Team (Current team: ${team})`

			console.log(`Changed to ${team} team`);


		})


		//Start screen mute button
		document.getElementById('muteButton').addEventListener('click', function () {
			isMuted = !isMuted;
			this.textContent = isMuted ? 'Unmute' : 'Mute';

			// Update mute state for intro video
			const introVideo = document.getElementById('introVideo');
			introVideo.muted = isMuted;

			// Update any currently playing videos in the video container
			const videoContainer = document.getElementById('videoContainer');
			const activeVideos = videoContainer.getElementsByTagName('video');
			for (let video of activeVideos) {
				video.muted = isMuted;
			}
		});

		document.querySelectorAll(".infoButton").forEach(button => {
			button.addEventListener("click", function () {
				window.open("Images/Rithmomachia_Booklet/Rithmomachia_Booklet.pdf", "_blank");
			});
		});

		//Can also mute and unmute audio by pressing m on the keyboard
		document.addEventListener("keydown", function (event) {
			if (event.key == "m" || event.key === "M") {
				isMuted = !isMuted;
				document.getElementById('muteButton').textContent = isMuted ? 'Unmute' : 'Mute';

				const introVideo = document.getElementById('introVideo');
				introVideo.muted = isMuted;

				const videoContainer = document.getElementById('videoContainer');
				const activeVideos = videoContainer.getElementsByTagName('video');
				for (let video of activeVideos) {
					video.muted = isMuted;
				}
			}
			else if (event.key == "s" || event.key == "S") {
				SkipVideo();
			}
			else if (event.key == "h" || event.key == "H") {
				$("#gameId").toggle();
			}
		});

		// Initialize with all victory conditions active
		    document.addEventListener('DOMContentLoaded', function() {
		      updateActiveVictories();
		    });
		    
		    // Add event listener to the save button
		    document.getElementById('saveVictoriesBtn').addEventListener('click', function() {
		      updateActiveVictories();
		      showSaveConfirmation();
		    });
		    
		    // Add event listeners to all checkboxes to track changes in real-time
		    const checkboxes = document.querySelectorAll('input[type="checkbox"]');
		    checkboxes.forEach(checkbox => {
		      checkbox.addEventListener('change', function() {
		        // Automatically update active victories when a checkbox changes
		        updateActiveVictories();
		      });
		    });
		    
		    // Function to update the active victory conditions without displaying them
		    function updateActiveVictories() {
		      const form = document.getElementById('victoryForm');
		      activeVictoryConditions = {};
		      
		      // Loop through all checkboxes
		      for (const checkbox of form.elements) {
		        if (checkbox.type === 'checkbox') {
		          // Store the checkbox state in the global object
		          activeVictoryConditions[checkbox.name] = checkbox.checked;
		        }
		      }
		      
		      // For debugging - you can remove this in production
		      console.log('Active Victory Conditions:', activeVictoryConditions);
		      
		      return activeVictoryConditions;
		    }
		    
		    // Function to show save confirmation message
		    function showSaveConfirmation() {
		      const confirmation = document.getElementById('saveConfirmation');
		      confirmation.classList.add('show');
		      
		      // Hide the confirmation after 2 seconds
		      setTimeout(() => {
		        confirmation.classList.remove('show');
		      }, 2000);
		    }
		    
		    // Function to get victory status programmatically (for your game code)
		    function getVictoryStatus() {
		      return activeVictoryConditions;
		    }

		//Plays preloaded intro video, initializes game, and unhides all elements that were previously hidden that are needed for the game. -Darin
		function StartGame() {
			setCanvasWidthandHeight();
			canvas.clear();
			setLengthandHeight();
			playIntroVideo();
			initializeGame();
			$.ajax({
				url: 'api/games',
				type: 'POST',
				contentType: 'application/json',
				dataType: 'text',
				success: function (resp) {
					$('#gameId').val(resp);
				},
				error: function () {
					alert('Network communication error');
				}
			});
			document.getElementById('fileLabel').classList.remove('hidden');
			document.getElementById('endLoopButton').classList.remove('hidden');
			document.getElementById('pause').classList.remove('hidden');
			document.getElementById('black-pyramid').classList.remove('hidden');
			document.getElementById('white-pyramid').classList.remove('hidden');
			document.getElementById('game-board').classList.remove('hidden');
			document.getElementById('volumeButton').classList.remove('hidden');
			document.getElementById('InfoButton').classList.remove('hidden');

		}

		//Function to skip videos when called 
		function SkipVideo() {
			const videoContainer = document.getElementById('videoContainer');
			if (videoContainer.innerHTML != "") {
				videoContainer.innerHTML = "";
				videoContainer.style.pointerEvents = 'none';
				cont = true;
			}
			else {
				console.log("No video to skip")
			}
		}

		// Load board background
		function loadBoardBackground() {
			return new Promise((resolve, reject) => {
				//Loading the board image seems to work correctly
				fabric.Image.fromURL(THEMES[currentTheme].board/*'Images/HUNT-Pieces/HUNT-NewBoard-01.png'*/, function (boardImage) {
					boardImage.set({
						selectable: false,
						evented: false,
						left: 0,
						top: 0,
						scaleX: CANVAS_WIDTH / boardImage.width,
						scaleY: CANVAS_HEIGHT / boardImage.height
					});


					if (team === "White") {
						boardImage.set({
							angle: 180,
							left: CANVAS_WIDTH,
							top: CANVAS_HEIGHT
						});
					} else {
						boardImage.set({
							angle: 0,
							left: 0,
							top: 0
						});
					}

					canvas.insertAt(boardImage, 0);
					resolve(boardImage);
				}, function (error) {
					console.error('Failed to load board image:', error);
					reject(error);
				});
			});
		}

		function loadPieceImage(piece) {
			return new Promise((resolve, reject) => {
				// Determine color and type
				const isWhite = piece === piece.toUpperCase();
				const baseType = piece[0].toLowerCase();
				let value = piece.slice(1);

				// Construct dynamic image path
				let imagePath;
				if (baseType == 'p') {
					imagePath = isWhite ? THEMES[currentTheme].pieces.whitePyramid : THEMES[currentTheme].pieces.blackPyramid;
					value = isWhite ? ['c1', 'c4', 't9', 't16', 's25', 's36'] : ['C16', 'T25', 'T36', 'S49', 'S64'];
				} else {
					// Use the theme's pieceFormat function for regular pieces (This Should fix it)
					imagePath = THEMES[currentTheme].pieces.pieceFormat(value, isWhite, baseType);


				}

				fabric.Image.fromURL(imagePath, function (img) {
					img.set({
						left: 0, // Will be set during board setup
						top: 0,
						originX: 'center',
						originY: 'center',
						//Scale seems to be way too big for piece scale -Fixed?
						scaleX: THEMES[currentTheme].pieceScale.x * length / img.width,
						scaleY: THEMES[currentTheme].pieceScale.y * height / img.height,
						hasControls: false,
						hasBorders: false,
						selectable: true,
						pieceColor: isWhite ? 'white' : 'black',
						pieceType: baseType,
						pieceValue: value
					});

					resolve(img);
				}, function (error) {
					console.error(`Failed to load image for piece ${piece}:`, error);
					reject(error);
				});
			});
		}

		async function addPieces() {
			//2 Board initial states for the different player team cases. Darin
			const initialBoardState = team === "Black" ? [
				['s49', 's28', 't16', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'T81', 'S153', 'S289'],
				['s121', 's66', 't36', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'T49', 'P', 'S169'],
				['.', 't12', 'c9', 'c3', '.', '.', '.', '.', '.', '.', '.', '.', 'C8', 'C64', 'T72', '.'],
				['.', 't30', 'c25', 'c5', '.', '.', '.', '.', '.', '.', '.', '.', 'C6', 'C36', 'T42', '.'],
				['.', 't56', 'c49', 'c7', '.', '.', '.', '.', '.', '.', '.', '.', 'C4', 'C16', 'T20', '.'],
				['.', 't90', 'c81', 'c9', '.', '.', '.', '.', '.', '.', '.', '.', 'C2', 'C4', 'T6', '.'],
				['s225', 's120', 't64', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'T25', 'S45', 'S81'],
				['s361', 'p', 't100', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'T9', 'S15', 'S25']
			] : [
				['S25', 'S15', 'T9', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't100', 'p', 's361'],
				['S81', 'S45', 'T25', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't64', 's120', 's225'],
				['.', 'T6', 'C4', 'C2', '.', '.', '.', '.', '.', '.', '.', '.', 'c9', 'c81', 't90', '.'],
				['.', 'T20', 'C16', 'C4', '.', '.', '.', '.', '.', '.', '.', '.', 'c7', 'c49', 't56', '.'],
				['.', 'T42', 'C36', 'C6', '.', '.', '.', '.', '.', '.', '.', '.', 'c5', 'c25', 't30', '.'],
				['.', 'T72', 'C64', 'C8', '.', '.', '.', '.', '.', '.', '.', '.', 'c3', 'c9', 't12', '.'],
				['S169', 'P', 'T49', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't36', 's66', 's121'],
				['S289', 'S153', 'T81', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't16', 's28', 's49']
			];

			const pieceLoadPromises = [];

			for (let rowIndex = 0; rowIndex < initialBoardState.length; rowIndex++) {
				for (let colIndex = 0; colIndex < initialBoardState[rowIndex].length; colIndex++) {
					let piece = initialBoardState[rowIndex][colIndex];

					if (piece !== '.') {
						const piecePromise = loadPieceImage(piece).then(pieceObject => {
							// Position the piece
							pieceObject.set({
								//Height and length seem to be off and test 3 has height and length flipped
								left: colIndex * height + height / 2 + THEMES[currentTheme].pieceOffset.left,
								top: rowIndex * length + length / 2 + THEMES[currentTheme].pieceOffset.top
							});

							boardState[rowIndex][colIndex] = pieceObject;
							canvas.add(pieceObject);
							if (pieceObject.pieceType == 'p') {
								updatePyramid(pieceObject.pieceColor, pieceObject.pieceValue);
							}
						});
						pieceLoadPromises.push(piecePromise);
					}
				};
			};
			// Wait for all pieces to be loaded before resolving
			await Promise.all(pieceLoadPromises);
		}

		//Made a play intro function for an easy access way to play the intro video without rewritting the playVideo function. -Darin
		function playIntroVideo() {
			const videoContainer = document.getElementById('videoContainer');

			videoContainer.innerHTML = '';
			videoContainer.style.pointerEvents = 'auto';

			const video = document.getElementById('introVideo');
			video.autoplay = true;
			video.loop = false;
			video.controls = false;
			video.muted = isMuted;

			videoContainer.appendChild(video);
			video.style.display = "block";
			video.play();

			video.addEventListener('ended', () => {
				videoContainer.innerHTML = '';
				videoContainer.style.pointerEvents = 'none';
			});
		}

		function playVideo(vid) {
			cont = false;
			const videoContainer = document.getElementById('videoContainer');

			videoContainer.innerHTML = '';
			videoContainer.style.pointerEvents = 'auto';

			const video = document.createElement('video');
			video.src = vid;
			video.autoplay = true;
			video.loop = false;
			video.controls = false;
			video.muted = isMuted;

			videoContainer.appendChild(video);

			video.addEventListener('ended', () => {
				let opacity = 1;
				const fadeInterval = setInterval(() => {
					if (opacity > 0) {
						opacity -= 0.01;
						video.style.opacity = opacity;
					} else {
						clearInterval(fadeInterval); // Stop fading when opacity reaches 0
					}
				}, 10); // Adjust the interval for speed
				setTimeout(function () {
					cont = true;
				}, 500);
				videoContainer.style.pointerEvents = 'none';
			});
		}

		function updatePyramid(w, ary) {
			// Determine if it's the white pyramid
			const isWhite = w === "white";

			// Get the appropriate div element
			const divElement = document.getElementById(isWhite ? "white-pyramid" : "black-pyramid");

			// Update the div with the heading and array content
			divElement.innerHTML = `
					<h3>${isWhite ? "White Pyramid" : "Black Pyramid"}</h3>
					${ary.map(item => `<p>${item}</p>`).join("")}
					`;

		}


		let gridObjects = [];
		//Only creates a proper grid for Lulu's board. Is toggleable with G. -Darin
		function createGrid() {
			if (gridObjects.length > 0) {
				// If grid exists, remove it
				gridObjects.forEach(obj => canvas.remove(obj));
				gridObjects = []; // Clear the stored grid objects
				canvas.renderAll();
				return; // Exit function since we just removed the grid
			}

			const rows = 8;
			const cols = 16;
			const alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];

			for (let row = 0; row < rows; row++) {
				for (let col = 0; col < cols; col++) {
					const centerX = col * length + length / 2 + THEMES[currentTheme].gridOffset.centerX;
					const centerY = row * height + height / 2 + THEMES[currentTheme].gridOffset.centerY;

					// Create grid square
					const rect = new fabric.Rect({
						left: centerX - length / 2,
						top: centerY - height / 2,
						width: length,
						height: height,
						fill: 'transparent',
						strokeWidth: 1,
						stroke: 'red',
						selectable: false,
						evented: false
					});

					// Determine algebraic notation
					const file = alphabet[row];
					const rank = col + 1;
					const algebraicNotation = `${file}${rank}`;

					// Create notation text
					const text = new fabric.Text(algebraicNotation, {
						left: centerX,
						top: centerY,
						fontSize: 12,
						fontFamily: 'Arial',
						fill: 'rgba(0, 0, 0, 0.5)',
						originX: 'center',
						originY: 'center',
						selectable: false,
						evented: false
					});

					// Add objects to canvas and store them
					canvas.add(rect);
					canvas.add(text);
					gridObjects.push(rect, text);
				}
			}

			canvas.renderAll();
		}


		function movePiece(from, to) {

			// Convert from algebraic notation to row and column
			function positionToIndices(position) {
				let c = position.toUpperCase().charCodeAt(0) - 65;
				let r = Number(position[1]) - 1;
				if (position[2]) {
					r = Number(position[1] + position[2]) - 1;
				}
				return { c, r };
			}

			const fromIndices = positionToIndices(from);
			const toIndices = positionToIndices(to);

			// Find the piece at the 'from' position (e.g., C4)
			const piece = boardState[fromIndices.c][fromIndices.r];

			if (piece) {
				// Calculate the target position (center of the square in grid)
				const targetCenterX = toIndices.r * height + height / 2 + THEMES[currentTheme].gridOffset.centerX;
				const targetCenterY = toIndices.c * length + length / 2 + THEMES[currentTheme].gridOffset.centerY;

				// Animate the piece to the target position with smooth transition
				piece.animate({
					left: targetCenterX,
					top: targetCenterY
				}, {
					duration: 1000, // Duration of the animation in milliseconds (adjust as needed)
					onChange: canvas.renderAll.bind(canvas), // Re-render the canvas during animation
					easing: fabric.util.ease.easeInOutQuad, // Smooth easing function
					onComplete: function () {
						// After the animation completes, update the piece position in the boardState
						boardState[fromIndices.c][fromIndices.r] = null;
						boardState[toIndices.c][toIndices.r] = piece;

						console.log(`Piece moved from ${from} to ${to}`);
					}
				});

			} else {
				console.log(`No piece found at ${from}`);
			}
		}

		function capturePiece(position, value, type) {
			switch (type) {
				//Fixed
				case "s":
					playVideo(THEMES[currentTheme].videos.siege(team));
					break;
				case "n":
					playVideo(THEMES[currentTheme].videos.encounter(team));
					break;
				case "r":
					playVideo(THEMES[currentTheme].videos.eruption(team));
					break;
				case "d":
					playVideo(THEMES[currentTheme].videos.deceit(team));
					break;
			}
			for (let i = 0; i < position.length; i++) {
				const c = position[i].toUpperCase().charCodeAt(0) - 65;
				const r = Number(position[i].slice(1)) - 1;

				// Find the piece at the specified position
				const piece = boardState[c][r];

				if (piece) {
					if (Array.isArray(piece.pieceValue)) {
						let index = piece.pieceValue.indexOf(value[i]);
						piece.pieceValue.splice(index, 1);
						updatePyramid(piece.pieceColor, piece.pieceValue);
						if (piece.pieceValue.length == 0) {
							piece.animate({ opacity: 0 }, {
								duration: 500,
								onChange: canvas.renderAll.bind(canvas),
								onComplete: () => {
									canvas.remove(piece);
									boardState[c][r] = null; // Clear the captured position
									console.log(`Pyramid at ${position[i]} empty.`);
								}
							});
						};
					}
					else {
						piece.animate({ opacity: 0 }, {
							duration: 500,
							onChange: canvas.renderAll.bind(canvas),
							onComplete: () => {
								canvas.remove(piece);
								boardState[c][r] = null; // Clear the captured position
								console.log(`Piece at ${position[i]} captured.`);
							}
						});
					}

				} else {
					console.log(`No piece found at ${position[i]} to capture.`);
				}
			}
		}

		function enableSnapping() {
			const rows = 8;
			const cols = 16;

			// Snap based on the closest grid center
			canvas.on('object:moving', function (event) {
				const obj = event.target;

				// Get the current mouse position
				const pointer = canvas.getPointer(event.e);

				// Variables to track the closest grid square
				let closestLeft = 0;
				let closestTop = 0;
				let smallestDistance = Infinity;

				let oldRowIndex = -1;
				let oldColIndex = -1;

				// Iterate over all grid square centers to find the closest
				for (let row = 0; row < rows; row++) {
					for (let col = 0; col < cols; col++) {
						// Calculate the center of the current grid square
						const gridCenterX = col * height + height / 2 + THEMES[currentTheme].gridOffset.centerX;
						const gridCenterY = row * length + length / 2 + THEMES[currentTheme].gridOffset.centerY;

						// Calculate the distance between the mouse pointer and the grid center
						const distance = Math.sqrt(
							Math.pow(pointer.x - gridCenterX, 2) + Math.pow(pointer.y - gridCenterY, 2)
						);

						// Update the closest grid square if this one is closer
						if (distance < smallestDistance) {
							smallestDistance = distance;
							closestLeft = gridCenterX;
							closestTop = gridCenterY;

							// Track the closest grid position (row, col)
							oldRowIndex = row;
							oldColIndex = col;
						}
					}
				}

				// Update the piece's position to the closest grid square center
				obj.left = closestLeft;
				obj.top = closestTop;

				// Remove the piece from the old position in boardState
				if (oldRowIndex !== -1 && oldColIndex !== -1) {
					boardState[oldRowIndex][oldColIndex] = null; // Clear the old position
				}

				// Calculate new row and column indices based on the snapped position
				const newRowIndex = Math.floor((closestTop - /*These 2 numbers are different between tests ->*/ 20) / length);
				const newColIndex = Math.floor((closestLeft - 125 / 4) / height);

				// Add the piece to the new position in boardState
				if (newRowIndex >= 0 && newRowIndex < rows && newColIndex >= 0 && newColIndex < cols) {
					boardState[newRowIndex][newColIndex] = obj; // Place the piece at the new position
				}
			});
		}

		function handleFileUpload(event) {
			stopExecution = false;
			const file = event.target.files[0];
			if (file) {
				//Swapped fuction specific reader for the global reader so it can be stopped at will. -Darin
				currentFileReader = new FileReader();
				currentFileReader.onload = function (e) {
					const fileContent = e.target.result;
					const moves = parseMoves(fileContent);
					resetGame().then(() => {
						executeMoves(moves);
					}).catch(error => {
						console.error('Error resetting the game:', error);
					})
				};
				currentFileReader.readAsText(file);
			}
		}

		function parseMoves(fileContent) {
			// Split the file content by lines
			const lines = fileContent.split('\n');
			const moves = [];

			lines.forEach(line => {
				if (line.trim()) {
					const movePairs = line.split(' '); // Split by space
					movePairs.forEach(pair => {
						if (pair.toUpperCase().includes('X')) {
							// Handle capture move (e.g., A1A2xC4c9)
							const parts = pair.split('x'); // Split by 'x'
							let [move, ...captures] = parts;
							const c = captures[0].match(/([snrd])(.*)/i);
							console.log(c);
							captures[0] = c[2];
							let take = [];
							let ids = [];

							// Extract capture position and unique ID (e.g., "C4" and "c9")
							captures.forEach(cap => {
								const captureMatch = cap.match(/([A-H][0-9]*)([c,t,s,C,T,S]\d+)/i);
								take.push(captureMatch[1]); // Capture position (e.g., "C4")
								ids.push(captureMatch[2]); // Captured piece info (e.g., "c9")
							});

							const [from, to] = splitMove(move); // Split the move into 'from' and 'to'
							moves.push([from, to, take, ids, c[1]]); // Add the parsed capture
						} else if (pair.length >= 4) {
							// Handle regular move (e.g., A1A2)
							const [from, to] = splitMove(pair);
							moves.push([from, to]); // Add regular move
						}
					});
				}
			});
			return moves;
		}


		// Helper function to split a move into from and to
		function splitMove(move) {
			let from;
			let to;
			if (isNaN(move.charAt(2))) {
				from = move.slice(0, 2);
				to = move.slice(2);
			}
			else {
				from = move.slice(0, 3);
				to = move.slice(3);
			}
			return [from, to]; // Return the from and to positions
		}


		function executeMoves(moves) {

			let index = 0;

			function playNextMove() {
				if (stopExecution) {
					console.log("Move execution stopped.");
					return;
				}
				if (index < moves.length) {
					if (cont) {
						const move = moves[index];
						const from = move[0]; // Starting position
						const to = move[1];   // Target position
						const captures = move[2] || null; // Optional capture position

						// Perform the move
						movePiece(from, to);

						// Handle capture if specified
						if (captures) {
							setTimeout(() => {
								capturePiece(captures, move[3], move[4]);
							}, 1100); // Slight delay to align with move animation
						}

						// Wait before moving to the next move
						setTimeout(() => {
							index++;
							playNextMove();

						}, 2000); // Adjust delay as needed
					} else {
						setTimeout(playNextMove, 1000);
					}
				} else {
					setTimeout(() => {
						resetGame().then(() => {
							if (isLooping) {
								executeMoves(moves);
							} else {
								isLooping = true
								document.getElementById('moveFileInput').value = '';
							}
						}).catch(error => {
							console.error('Error resetting the game:', error);
						})

					}, 1000);

				}
			}

			playNextMove(); // Start executing moves
		}

		function StopFileExecution() {
			currentFileReader = null;
			stopExecution = true;
			isLooping = false;
		}

		function resetGame() {
			return new Promise((resolve, reject) => {
				// Clear all objects on the canvas
				canvas.clear();

				// Reset the board state to empty
				boardState = Array(8).fill().map(() => Array(16).fill(null));

				// Reload the board background
				loadBoardBackground().then(() => {

					// Wait for addPieces to finish loading the pieces before resolving the promise
					addPieces().then(() => {
						resolve(); // Resolve the promise once all pieces are loaded
					}).catch((error) => {
						console.error('Error loading pieces:', error);
						reject(error); // Reject if there's an error loading pieces
					});
				}).catch((error) => {
					console.error('Error loading board background:', error);
					reject(error); // Reject if there's an error loading the board background
				});

			});
		}

		function handleReset() {
			resetGame().then(() => {
				StopFileExecution();
				document.getElementById('moveFileInput').value = '';
			}).catch(error => {
				console.error("Error during reset:", error);
			});
		}

		// Initialize the game
		async function initializeGame() {
			try {

				// Load the background image first
				await loadBoardBackground();

				await addPieces();

				enableSnapping();
				canvas.renderAll();
			} catch (error) {
				console.error('Game initialization failed:', error);
			}
		}

		function PauseButton() {
			const button = document.getElementById("pause");
			// Change the button text to a new value
			if (button.innerHTML === "Pause") {
				button.innerHTML = "Play";
				cont = false;
			} else {
				button.innerHTML = "Pause";
				cont = true;
			}
		}

		//Toggle for grid -Darin 
		document.addEventListener("keydown", (event) => {
			if (event.key === "g" || event.key === "G") {
				createGrid();
			}
		});

		document.getElementById('moveFileInput').replaceWith(document.getElementById('moveFileInput').cloneNode(true));
		document.getElementById('moveFileInput').addEventListener('change', handleFileUpload);
	</script>
</body>

</html>
